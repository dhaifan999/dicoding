# -*- coding: utf-8 -*-
"""RS_Dhaifan Satriaji_M128X0209.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13oPGVLDwl7G4ozd_90h7zRXhhpWbiiWh

**Nama**  : Dhaifan Satriaji

**ID Siswa** : M128X0209

**Kelas** : M06

# Importing Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import numpy as np
import pandas as pd

import seaborn as sns
import plotly.express as px 
import matplotlib.pyplot as plt
# %matplotlib inline

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
from sklearn.metrics import euclidean_distances
from scipy.spatial.distance import cdist

import warnings
warnings.filterwarnings("ignore")

"""# Data Loading"""

from google.colab import files
files.upload()

"""# Data Exploration"""

df_music = pd.read_csv('/content/Spotify-2000.csv')
print("Shape:", df_music.shape)
df_music.head()

"""Deskripsi Variabel"""

df_music.info()

"""Menangani Missing Value"""

df_music.isnull().sum()

"""Korelasi Fitur"""

from yellowbrick.target import FeatureCorrelation

feature_names = ['Index', 'Year', 'Beats Per Minute (BPM)', 'Energy', 'Danceability', 
                 'Loudness (dB)', 'Liveness', 'Valence', 'Acousticness','Speechiness']

X, y = df_music[feature_names], df_music['Popularity']

features = np.array(feature_names)

visualizer = FeatureCorrelation(labels=features)

plt.rcParams['figure.figsize']=(20,20)
visualizer.fit(X, y)     
visualizer.show()

"""# Data Understanding

Music Over Time
"""

def get_decade(year):
    period_start = int(year/10) * 10
    decade = '{}s'.format(period_start)
    return decade

df_music['decade'] = df_music['Year'].apply(get_decade)

sns.set(rc={'figure.figsize':(11 ,6)})
sns.countplot(df_music['decade'])

"""Fitur Sound"""

sound_features = ['Acousticness', 'Danceability', 'Energy', 'Liveness', 'Speechiness', 'Valence']
fig = px.line(df_music, x='Year', y=sound_features)
fig.show()

"""Characteristics of Different Genres"""

top10_genres = df_music.nlargest(10, 'Popularity')

fig = px.bar(top10_genres, x='Top Genre', y=['Valence', 'Energy', 'Danceability', 'Acousticness'], barmode='group')
fig.show()

"""Clustering Genres with K-Means"""

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

cluster_pipeline = Pipeline([('scaler', StandardScaler()), ('kmeans', KMeans(n_clusters=10))])
X = df_music.select_dtypes(np.number)
cluster_pipeline.fit(X)
df_music['cluster'] = cluster_pipeline.predict(X)

from sklearn.manifold import TSNE

tsne_pipeline = Pipeline([('scaler', StandardScaler()), ('tsne', TSNE(n_components=2, verbose=1))])
genre_embedding = tsne_pipeline.fit_transform(X)
projection = pd.DataFrame(columns=['x', 'y'], data=genre_embedding)
projection['Top Genre'] = df_music['Top Genre']
projection['cluster'] = df_music['cluster']

fig = px.scatter(
    projection, x='x', y='y', color='cluster', hover_data=['x', 'y', 'Top Genre'])
fig.show()

"""Clustering Songs with K-Means"""

song_cluster_pipeline = Pipeline([('scaler', StandardScaler()), 
                                  ('kmeans', KMeans(n_clusters=20, 
                                   verbose=False))
                                 ], verbose=False)

X = df_music.select_dtypes(np.number)
number_cols = list(X.columns)
song_cluster_pipeline.fit(X)
song_cluster_labels = song_cluster_pipeline.predict(X)
df_music['cluster_label'] = song_cluster_labels

from sklearn.decomposition import PCA

pca_pipeline = Pipeline([('scaler', StandardScaler()), ('PCA', PCA(n_components=2))])
song_embedding = pca_pipeline.fit_transform(X)
projection = pd.DataFrame(columns=['x', 'y'], data=song_embedding)
projection['Title'] = df_music['Title']
projection['cluster'] = df_music['cluster_label']

fig = px.scatter(
    projection, x='x', y='y', color='cluster', hover_data=['x', 'y', 'Title'])
fig.show()

"""Build Recommender System"""

from sklearn.preprocessing import normalize
df_music['song_id']=df_music.index
df = df_music[["Acousticness", 'Danceability', 'Energy', "Liveness", "Speechiness", "Valence"]]
df.index = df_music['song_id']

df_normalized = pd.DataFrame(normalize(df, axis=1))
df_normalized.columns = df.columns
df_normalized.index = df.index
df_normalized.head()

"""
Music Recommender based on different distance calculation approaches

df_normalized: normalized song data
distance_method: distance calculation approach: e.g. cosine, euclidean, hamming
song_id: find similar songs based on the selected song
N: Top N song(s)

return 1) song data of selected song and Top N recommendation, 
2) song id and song name of Top N recommendation
"""

from sklearn.metrics.pairwise import cosine_similarity
from scipy.spatial.distance import cosine, euclidean, hamming
def Content_filter_music_recommender(song_id, N):
    distance_method = cosine
    allSongs = pd.DataFrame(df_normalized.index)
    allSongs = allSongs[allSongs.song_id != song_id]
    allSongs["distance"] = allSongs["song_id"].apply(lambda x: distance_method(df_normalized.loc[song_id], df_normalized.loc[x]))
    # sort by distance then recipe id, the smaller value of recipe id will be picked. 
    TopNRecommendation = allSongs.sort_values(["distance"]).head(N).sort_values(by=['distance', 'song_id'])
    #print(data['name'].loc[song_id, :])
    Recommendation = pd.merge(TopNRecommendation , df_music, how='inner', on='song_id')
    SongName = Recommendation['Title']
    return SongName

SongName=Content_filter_music_recommender(3, 5)
SongName